
Lab4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000020  00800100  00000cc4  00000d58  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000cc4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000063b  00800120  00800120  00000d78  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000d78  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000da8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000001d0  00000000  00000000  00000de8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002435  00000000  00000000  00000fb8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000f7d  00000000  00000000  000033ed  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000013e9  00000000  00000000  0000436a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000047c  00000000  00000000  00005754  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000cd8  00000000  00000000  00005bd0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001218  00000000  00000000  000068a8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000001c8  00000000  00000000  00007ac0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	45 c0       	rjmp	.+138    	; 0x8c <__ctors_end>
   2:	00 00       	nop
   4:	60 c0       	rjmp	.+192    	; 0xc6 <__bad_interrupt>
   6:	00 00       	nop
   8:	5e c0       	rjmp	.+188    	; 0xc6 <__bad_interrupt>
   a:	00 00       	nop
   c:	5c c0       	rjmp	.+184    	; 0xc6 <__bad_interrupt>
   e:	00 00       	nop
  10:	5a c0       	rjmp	.+180    	; 0xc6 <__bad_interrupt>
  12:	00 00       	nop
  14:	58 c0       	rjmp	.+176    	; 0xc6 <__bad_interrupt>
  16:	00 00       	nop
  18:	56 c0       	rjmp	.+172    	; 0xc6 <__bad_interrupt>
  1a:	00 00       	nop
  1c:	54 c0       	rjmp	.+168    	; 0xc6 <__bad_interrupt>
  1e:	00 00       	nop
  20:	52 c0       	rjmp	.+164    	; 0xc6 <__bad_interrupt>
  22:	00 00       	nop
  24:	50 c0       	rjmp	.+160    	; 0xc6 <__bad_interrupt>
  26:	00 00       	nop
  28:	4e c0       	rjmp	.+156    	; 0xc6 <__bad_interrupt>
  2a:	00 00       	nop
  2c:	4c c0       	rjmp	.+152    	; 0xc6 <__bad_interrupt>
  2e:	00 00       	nop
  30:	4a c0       	rjmp	.+148    	; 0xc6 <__bad_interrupt>
  32:	00 00       	nop
  34:	d7 c2       	rjmp	.+1454   	; 0x5e4 <__vector_13>
  36:	00 00       	nop
  38:	46 c0       	rjmp	.+140    	; 0xc6 <__bad_interrupt>
  3a:	00 00       	nop
  3c:	44 c0       	rjmp	.+136    	; 0xc6 <__bad_interrupt>
  3e:	00 00       	nop
  40:	42 c0       	rjmp	.+132    	; 0xc6 <__bad_interrupt>
  42:	00 00       	nop
  44:	40 c0       	rjmp	.+128    	; 0xc6 <__bad_interrupt>
  46:	00 00       	nop
  48:	3e c0       	rjmp	.+124    	; 0xc6 <__bad_interrupt>
  4a:	00 00       	nop
  4c:	3c c0       	rjmp	.+120    	; 0xc6 <__bad_interrupt>
  4e:	00 00       	nop
  50:	3a c0       	rjmp	.+116    	; 0xc6 <__bad_interrupt>
  52:	00 00       	nop
  54:	38 c0       	rjmp	.+112    	; 0xc6 <__bad_interrupt>
  56:	00 00       	nop
  58:	36 c0       	rjmp	.+108    	; 0xc6 <__bad_interrupt>
  5a:	00 00       	nop
  5c:	34 c0       	rjmp	.+104    	; 0xc6 <__bad_interrupt>
  5e:	00 00       	nop
  60:	32 c0       	rjmp	.+100    	; 0xc6 <__bad_interrupt>
  62:	00 00       	nop
  64:	30 c0       	rjmp	.+96     	; 0xc6 <__bad_interrupt>
  66:	00 00       	nop
  68:	2e c0       	rjmp	.+92     	; 0xc6 <__bad_interrupt>
  6a:	00 00       	nop
  6c:	2c c0       	rjmp	.+88     	; 0xc6 <__bad_interrupt>
  6e:	00 00       	nop
  70:	2a c0       	rjmp	.+84     	; 0xc6 <__bad_interrupt>
  72:	00 00       	nop
  74:	28 c0       	rjmp	.+80     	; 0xc6 <__bad_interrupt>
  76:	00 00       	nop
  78:	26 c0       	rjmp	.+76     	; 0xc6 <__bad_interrupt>
  7a:	00 00       	nop
  7c:	24 c0       	rjmp	.+72     	; 0xc6 <__bad_interrupt>
  7e:	00 00       	nop
  80:	22 c0       	rjmp	.+68     	; 0xc6 <__bad_interrupt>
  82:	00 00       	nop
  84:	20 c0       	rjmp	.+64     	; 0xc6 <__bad_interrupt>
  86:	00 00       	nop
  88:	1e c0       	rjmp	.+60     	; 0xc6 <__bad_interrupt>
	...

0000008c <__ctors_end>:
  8c:	11 24       	eor	r1, r1
  8e:	1f be       	out	0x3f, r1	; 63
  90:	cf ef       	ldi	r28, 0xFF	; 255
  92:	d0 e4       	ldi	r29, 0x40	; 64
  94:	de bf       	out	0x3e, r29	; 62
  96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
  98:	11 e0       	ldi	r17, 0x01	; 1
  9a:	a0 e0       	ldi	r26, 0x00	; 0
  9c:	b1 e0       	ldi	r27, 0x01	; 1
  9e:	e4 ec       	ldi	r30, 0xC4	; 196
  a0:	fc e0       	ldi	r31, 0x0C	; 12
  a2:	00 e0       	ldi	r16, 0x00	; 0
  a4:	0b bf       	out	0x3b, r16	; 59
  a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
  a8:	07 90       	elpm	r0, Z+
  aa:	0d 92       	st	X+, r0
  ac:	a0 32       	cpi	r26, 0x20	; 32
  ae:	b1 07       	cpc	r27, r17
  b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
  b2:	27 e0       	ldi	r18, 0x07	; 7
  b4:	a0 e2       	ldi	r26, 0x20	; 32
  b6:	b1 e0       	ldi	r27, 0x01	; 1
  b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
  ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
  bc:	ab 35       	cpi	r26, 0x5B	; 91
  be:	b2 07       	cpc	r27, r18
  c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
  c2:	2e d1       	rcall	.+604    	; 0x320 <main>
  c4:	fd c5       	rjmp	.+3066   	; 0xcc0 <_exit>

000000c6 <__bad_interrupt>:
  c6:	9c cf       	rjmp	.-200    	; 0x0 <__vectors>

000000c8 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
  c8:	cf 93       	push	r28
  ca:	df 93       	push	r29
  cc:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
  ce:	dd d3       	rcall	.+1978   	; 0x88a <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
  d0:	20 91 20 01 	lds	r18, 0x0120	; 0x800120 <__data_end>
  d4:	30 91 21 01 	lds	r19, 0x0121	; 0x800121 <__data_end+0x1>
  d8:	ce 01       	movw	r24, r28
  da:	82 0f       	add	r24, r18
  dc:	93 1f       	adc	r25, r19
  de:	8c 3d       	cpi	r24, 0xDC	; 220
  e0:	45 e0       	ldi	r20, 0x05	; 5
  e2:	94 07       	cpc	r25, r20
  e4:	58 f4       	brcc	.+22     	; 0xfc <pvPortMalloc+0x34>
  e6:	28 17       	cp	r18, r24
  e8:	39 07       	cpc	r19, r25
  ea:	58 f4       	brcc	.+22     	; 0x102 <pvPortMalloc+0x3a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
  ec:	e9 01       	movw	r28, r18
  ee:	ce 5d       	subi	r28, 0xDE	; 222
  f0:	de 4f       	sbci	r29, 0xFE	; 254
			xNextFreeByte += xWantedSize;			
  f2:	90 93 21 01 	sts	0x0121, r25	; 0x800121 <__data_end+0x1>
  f6:	80 93 20 01 	sts	0x0120, r24	; 0x800120 <__data_end>
  fa:	05 c0       	rjmp	.+10     	; 0x106 <pvPortMalloc+0x3e>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
  fc:	c0 e0       	ldi	r28, 0x00	; 0
  fe:	d0 e0       	ldi	r29, 0x00	; 0
 100:	02 c0       	rjmp	.+4      	; 0x106 <pvPortMalloc+0x3e>
 102:	c0 e0       	ldi	r28, 0x00	; 0
 104:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
 106:	88 d4       	rcall	.+2320   	; 0xa18 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
 108:	ce 01       	movw	r24, r28
 10a:	df 91       	pop	r29
 10c:	cf 91       	pop	r28
 10e:	08 95       	ret

00000110 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 110:	08 95       	ret

00000112 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
 112:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
 114:	03 96       	adiw	r24, 0x03	; 3
 116:	92 83       	std	Z+2, r25	; 0x02
 118:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 11a:	2f ef       	ldi	r18, 0xFF	; 255
 11c:	3f ef       	ldi	r19, 0xFF	; 255
 11e:	34 83       	std	Z+4, r19	; 0x04
 120:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
 122:	96 83       	std	Z+6, r25	; 0x06
 124:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
 126:	90 87       	std	Z+8, r25	; 0x08
 128:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
 12a:	10 82       	st	Z, r1
 12c:	08 95       	ret

0000012e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 12e:	fc 01       	movw	r30, r24
 130:	11 86       	std	Z+9, r1	; 0x09
 132:	10 86       	std	Z+8, r1	; 0x08
 134:	08 95       	ret

00000136 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
 136:	cf 93       	push	r28
 138:	df 93       	push	r29
 13a:	fc 01       	movw	r30, r24
 13c:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
 13e:	21 81       	ldd	r18, Z+1	; 0x01
 140:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
 142:	e9 01       	movw	r28, r18
 144:	8a 81       	ldd	r24, Y+2	; 0x02
 146:	9b 81       	ldd	r25, Y+3	; 0x03
 148:	13 96       	adiw	r26, 0x03	; 3
 14a:	9c 93       	st	X, r25
 14c:	8e 93       	st	-X, r24
 14e:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
 150:	81 81       	ldd	r24, Z+1	; 0x01
 152:	92 81       	ldd	r25, Z+2	; 0x02
 154:	15 96       	adiw	r26, 0x05	; 5
 156:	9c 93       	st	X, r25
 158:	8e 93       	st	-X, r24
 15a:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
 15c:	8a 81       	ldd	r24, Y+2	; 0x02
 15e:	9b 81       	ldd	r25, Y+3	; 0x03
 160:	ec 01       	movw	r28, r24
 162:	7d 83       	std	Y+5, r23	; 0x05
 164:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
 166:	e9 01       	movw	r28, r18
 168:	7b 83       	std	Y+3, r23	; 0x03
 16a:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
 16c:	72 83       	std	Z+2, r23	; 0x02
 16e:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 170:	19 96       	adiw	r26, 0x09	; 9
 172:	fc 93       	st	X, r31
 174:	ee 93       	st	-X, r30
 176:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
 178:	80 81       	ld	r24, Z
 17a:	8f 5f       	subi	r24, 0xFF	; 255
 17c:	80 83       	st	Z, r24
}
 17e:	df 91       	pop	r29
 180:	cf 91       	pop	r28
 182:	08 95       	ret

00000184 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
 184:	cf 93       	push	r28
 186:	df 93       	push	r29
 188:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
 18a:	48 81       	ld	r20, Y
 18c:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 18e:	4f 3f       	cpi	r20, 0xFF	; 255
 190:	2f ef       	ldi	r18, 0xFF	; 255
 192:	52 07       	cpc	r21, r18
 194:	31 f4       	brne	.+12     	; 0x1a2 <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 196:	dc 01       	movw	r26, r24
 198:	17 96       	adiw	r26, 0x07	; 7
 19a:	ed 91       	ld	r30, X+
 19c:	fc 91       	ld	r31, X
 19e:	18 97       	sbiw	r26, 0x08	; 8
 1a0:	17 c0       	rjmp	.+46     	; 0x1d0 <vListInsert+0x4c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
 1a2:	fc 01       	movw	r30, r24
 1a4:	33 96       	adiw	r30, 0x03	; 3
 1a6:	dc 01       	movw	r26, r24
 1a8:	15 96       	adiw	r26, 0x05	; 5
 1aa:	2d 91       	ld	r18, X+
 1ac:	3c 91       	ld	r19, X
 1ae:	16 97       	sbiw	r26, 0x06	; 6
 1b0:	d9 01       	movw	r26, r18
 1b2:	2d 91       	ld	r18, X+
 1b4:	3c 91       	ld	r19, X
 1b6:	42 17       	cp	r20, r18
 1b8:	53 07       	cpc	r21, r19
 1ba:	50 f0       	brcs	.+20     	; 0x1d0 <vListInsert+0x4c>
 1bc:	02 80       	ldd	r0, Z+2	; 0x02
 1be:	f3 81       	ldd	r31, Z+3	; 0x03
 1c0:	e0 2d       	mov	r30, r0
 1c2:	a2 81       	ldd	r26, Z+2	; 0x02
 1c4:	b3 81       	ldd	r27, Z+3	; 0x03
 1c6:	2d 91       	ld	r18, X+
 1c8:	3c 91       	ld	r19, X
 1ca:	42 17       	cp	r20, r18
 1cc:	53 07       	cpc	r21, r19
 1ce:	b0 f7       	brcc	.-20     	; 0x1bc <vListInsert+0x38>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 1d0:	a2 81       	ldd	r26, Z+2	; 0x02
 1d2:	b3 81       	ldd	r27, Z+3	; 0x03
 1d4:	bb 83       	std	Y+3, r27	; 0x03
 1d6:	aa 83       	std	Y+2, r26	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
 1d8:	15 96       	adiw	r26, 0x05	; 5
 1da:	dc 93       	st	X, r29
 1dc:	ce 93       	st	-X, r28
 1de:	14 97       	sbiw	r26, 0x04	; 4
	pxNewListItem->pxPrevious = pxIterator;
 1e0:	fd 83       	std	Y+5, r31	; 0x05
 1e2:	ec 83       	std	Y+4, r30	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
 1e4:	d3 83       	std	Z+3, r29	; 0x03
 1e6:	c2 83       	std	Z+2, r28	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 1e8:	99 87       	std	Y+9, r25	; 0x09
 1ea:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
 1ec:	fc 01       	movw	r30, r24
 1ee:	20 81       	ld	r18, Z
 1f0:	2f 5f       	subi	r18, 0xFF	; 255
 1f2:	20 83       	st	Z, r18
}
 1f4:	df 91       	pop	r29
 1f6:	cf 91       	pop	r28
 1f8:	08 95       	ret

000001fa <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
 1fa:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 1fc:	a2 81       	ldd	r26, Z+2	; 0x02
 1fe:	b3 81       	ldd	r27, Z+3	; 0x03
 200:	84 81       	ldd	r24, Z+4	; 0x04
 202:	95 81       	ldd	r25, Z+5	; 0x05
 204:	15 96       	adiw	r26, 0x05	; 5
 206:	9c 93       	st	X, r25
 208:	8e 93       	st	-X, r24
 20a:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 20c:	a4 81       	ldd	r26, Z+4	; 0x04
 20e:	b5 81       	ldd	r27, Z+5	; 0x05
 210:	82 81       	ldd	r24, Z+2	; 0x02
 212:	93 81       	ldd	r25, Z+3	; 0x03
 214:	13 96       	adiw	r26, 0x03	; 3
 216:	9c 93       	st	X, r25
 218:	8e 93       	st	-X, r24
 21a:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
 21c:	a0 85       	ldd	r26, Z+8	; 0x08
 21e:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 220:	11 96       	adiw	r26, 0x01	; 1
 222:	8d 91       	ld	r24, X+
 224:	9c 91       	ld	r25, X
 226:	12 97       	sbiw	r26, 0x02	; 2
 228:	8e 17       	cp	r24, r30
 22a:	9f 07       	cpc	r25, r31
 22c:	31 f4       	brne	.+12     	; 0x23a <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 22e:	84 81       	ldd	r24, Z+4	; 0x04
 230:	95 81       	ldd	r25, Z+5	; 0x05
 232:	12 96       	adiw	r26, 0x02	; 2
 234:	9c 93       	st	X, r25
 236:	8e 93       	st	-X, r24
 238:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
 23a:	11 86       	std	Z+9, r1	; 0x09
 23c:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
 23e:	8c 91       	ld	r24, X
 240:	81 50       	subi	r24, 0x01	; 1
 242:	8c 93       	st	X, r24
 244:	08 95       	ret

00000246 <LEDS_Tick>:


enum LightState {Light_Off,Light_On} state;

void Light_Init(){
	state = Light_Off;
 246:	93 b1       	in	r25, 0x03	; 3
 248:	80 91 59 07 	lds	r24, 0x0759	; 0x800759 <led_state>
 24c:	88 23       	and	r24, r24
 24e:	19 f0       	breq	.+6      	; 0x256 <LEDS_Tick+0x10>
 250:	81 30       	cpi	r24, 0x01	; 1
 252:	29 f0       	breq	.+10     	; 0x25e <LEDS_Tick+0x18>
 254:	08 95       	ret
 256:	81 e0       	ldi	r24, 0x01	; 1
 258:	80 93 59 07 	sts	0x0759, r24	; 0x800759 <led_state>
 25c:	08 95       	ret
 25e:	90 ff       	sbrs	r25, 0
 260:	03 c0       	rjmp	.+6      	; 0x268 <LEDS_Tick+0x22>
 262:	10 92 fe 06 	sts	0x06FE, r1	; 0x8006fe <flag>
 266:	08 95       	ret
 268:	81 e0       	ldi	r24, 0x01	; 1
 26a:	80 93 fe 06 	sts	0x06FE, r24	; 0x8006fe <flag>
 26e:	08 95       	ret

00000270 <LedSecTask>:
 270:	10 92 59 07 	sts	0x0759, r1	; 0x800759 <led_state>
 274:	e8 df       	rcall	.-48     	; 0x246 <LEDS_Tick>
 276:	82 e3       	ldi	r24, 0x32	; 50
 278:	90 e0       	ldi	r25, 0x00	; 0
 27a:	4f d4       	rcall	.+2206   	; 0xb1a <vTaskDelay>
 27c:	fb cf       	rjmp	.-10     	; 0x274 <LedSecTask+0x4>

0000027e <Light_Tick>:
}


void Light_Tick(){
	//Actions
	switch(state)
 27e:	80 91 5a 07 	lds	r24, 0x075A	; 0x80075a <state>
 282:	88 23       	and	r24, r24
 284:	19 f0       	breq	.+6      	; 0x28c <Light_Tick+0xe>
 286:	81 30       	cpi	r24, 0x01	; 1
 288:	19 f0       	breq	.+6      	; 0x290 <Light_Tick+0x12>
 28a:	04 c0       	rjmp	.+8      	; 0x294 <Light_Tick+0x16>
	{
		case Light_Off:
		PORTC = 0x00;
 28c:	18 b8       	out	0x08, r1	; 8
		break;
 28e:	02 c0       	rjmp	.+4      	; 0x294 <Light_Tick+0x16>
		
		case Light_On:
		PORTC = 0x04;
 290:	84 e0       	ldi	r24, 0x04	; 4
 292:	88 b9       	out	0x08, r24	; 8
		
		default:
		break;
	}
	//Transitions
	switch(state)
 294:	80 91 5a 07 	lds	r24, 0x075A	; 0x80075a <state>
 298:	88 23       	and	r24, r24
 29a:	19 f0       	breq	.+6      	; 0x2a2 <Light_Tick+0x24>
 29c:	81 30       	cpi	r24, 0x01	; 1
 29e:	41 f0       	breq	.+16     	; 0x2b0 <Light_Tick+0x32>
 2a0:	08 95       	ret
	{
		case Light_Off:
		if (flag == 1)
 2a2:	80 91 fe 06 	lds	r24, 0x06FE	; 0x8006fe <flag>
 2a6:	81 30       	cpi	r24, 0x01	; 1
 2a8:	49 f4       	brne	.+18     	; 0x2bc <Light_Tick+0x3e>
		{
			state = Light_On;
 2aa:	80 93 5a 07 	sts	0x075A, r24	; 0x80075a <state>
 2ae:	08 95       	ret
		}
		break;
		
		case Light_On:
		if (flag == 0)
 2b0:	80 91 fe 06 	lds	r24, 0x06FE	; 0x8006fe <flag>
 2b4:	81 11       	cpse	r24, r1
 2b6:	02 c0       	rjmp	.+4      	; 0x2bc <Light_Tick+0x3e>
		{
			state = Light_Off;
 2b8:	10 92 5a 07 	sts	0x075A, r1	; 0x80075a <state>
 2bc:	08 95       	ret

000002be <LightSecTask>:


enum LightState {Light_Off,Light_On} state;

void Light_Init(){
	state = Light_Off;
 2be:	10 92 5a 07 	sts	0x075A, r1	; 0x80075a <state>
void LightSecTask()
{
	Light_Init();
	for(;;)
	{
		Light_Tick();
 2c2:	dd df       	rcall	.-70     	; 0x27e <Light_Tick>
		vTaskDelay(50);
 2c4:	82 e3       	ldi	r24, 0x32	; 50
 2c6:	90 e0       	ldi	r25, 0x00	; 0
 2c8:	28 d4       	rcall	.+2128   	; 0xb1a <vTaskDelay>
	}
 2ca:	fb cf       	rjmp	.-10     	; 0x2c2 <LightSecTask+0x4>

000002cc <StartSecPulse>:
}


void StartSecPulse(unsigned portBASE_TYPE Priority)
{
 2cc:	af 92       	push	r10
 2ce:	bf 92       	push	r11
 2d0:	cf 92       	push	r12
 2d2:	df 92       	push	r13
 2d4:	ef 92       	push	r14
 2d6:	ff 92       	push	r15
 2d8:	0f 93       	push	r16
 2da:	cf 93       	push	r28
	xTaskCreate(LedSecTask, (signed portCHAR *)"LedSecTask", configMINIMAL_STACK_SIZE, NULL, Priority, NULL );
 2dc:	a1 2c       	mov	r10, r1
 2de:	b1 2c       	mov	r11, r1
 2e0:	c1 2c       	mov	r12, r1
 2e2:	d1 2c       	mov	r13, r1
 2e4:	e1 2c       	mov	r14, r1
 2e6:	f1 2c       	mov	r15, r1
 2e8:	08 2f       	mov	r16, r24
 2ea:	20 e0       	ldi	r18, 0x00	; 0
 2ec:	30 e0       	ldi	r19, 0x00	; 0
 2ee:	45 e5       	ldi	r20, 0x55	; 85
 2f0:	50 e0       	ldi	r21, 0x00	; 0
 2f2:	62 e0       	ldi	r22, 0x02	; 2
 2f4:	71 e0       	ldi	r23, 0x01	; 1
 2f6:	88 e3       	ldi	r24, 0x38	; 56
 2f8:	91 e0       	ldi	r25, 0x01	; 1
 2fa:	ab d1       	rcall	.+854    	; 0x652 <xTaskGenericCreate>
	xTaskCreate(LightSecTask, (signed portCHAR *)"LightSecTask", configMINIMAL_STACK_SIZE, NULL, Priority, NULL );
 2fc:	20 e0       	ldi	r18, 0x00	; 0
 2fe:	30 e0       	ldi	r19, 0x00	; 0
 300:	45 e5       	ldi	r20, 0x55	; 85
 302:	50 e0       	ldi	r21, 0x00	; 0
 304:	6d e0       	ldi	r22, 0x0D	; 13
 306:	71 e0       	ldi	r23, 0x01	; 1
 308:	8f e5       	ldi	r24, 0x5F	; 95
 30a:	91 e0       	ldi	r25, 0x01	; 1
 30c:	a2 d1       	rcall	.+836    	; 0x652 <xTaskGenericCreate>
}
 30e:	cf 91       	pop	r28
 310:	0f 91       	pop	r16
 312:	ff 90       	pop	r15
 314:	ef 90       	pop	r14
 316:	df 90       	pop	r13
 318:	cf 90       	pop	r12
 31a:	bf 90       	pop	r11
 31c:	af 90       	pop	r10
 31e:	08 95       	ret

00000320 <main>:

int main(void)
{
	DDRB = 0x00; PORTB = 0xFF;
 320:	14 b8       	out	0x04, r1	; 4
 322:	8f ef       	ldi	r24, 0xFF	; 255
 324:	85 b9       	out	0x05, r24	; 5
	DDRC = 0xFF; PORTC = 0x00;
 326:	87 b9       	out	0x07, r24	; 7
 328:	18 b8       	out	0x08, r1	; 8
	//Start Tasks
	StartSecPulse(1);
 32a:	81 e0       	ldi	r24, 0x01	; 1
 32c:	cf df       	rcall	.-98     	; 0x2cc <StartSecPulse>
	//RunSchedular
	vTaskStartScheduler();
 32e:	84 d2       	rcall	.+1288   	; 0x838 <vTaskStartScheduler>
	//PORTC = 0x01;
	//PORTC = 0x02;
	//PORTC = 0x03;
	
	return 0;
 330:	80 e0       	ldi	r24, 0x00	; 0
 332:	90 e0       	ldi	r25, 0x00	; 0
 334:	08 95       	ret

00000336 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
 336:	31 e1       	ldi	r19, 0x11	; 17
 338:	fc 01       	movw	r30, r24
 33a:	30 83       	st	Z, r19
 33c:	31 97       	sbiw	r30, 0x01	; 1
 33e:	22 e2       	ldi	r18, 0x22	; 34
 340:	20 83       	st	Z, r18
 342:	31 97       	sbiw	r30, 0x01	; 1
 344:	a3 e3       	ldi	r26, 0x33	; 51
 346:	a0 83       	st	Z, r26
 348:	31 97       	sbiw	r30, 0x01	; 1
 34a:	60 83       	st	Z, r22
 34c:	31 97       	sbiw	r30, 0x01	; 1
 34e:	70 83       	st	Z, r23
 350:	31 97       	sbiw	r30, 0x01	; 1
 352:	10 82       	st	Z, r1
 354:	31 97       	sbiw	r30, 0x01	; 1
 356:	60 e8       	ldi	r22, 0x80	; 128
 358:	60 83       	st	Z, r22
 35a:	31 97       	sbiw	r30, 0x01	; 1
 35c:	10 82       	st	Z, r1
 35e:	31 97       	sbiw	r30, 0x01	; 1
 360:	62 e0       	ldi	r22, 0x02	; 2
 362:	60 83       	st	Z, r22
 364:	31 97       	sbiw	r30, 0x01	; 1
 366:	63 e0       	ldi	r22, 0x03	; 3
 368:	60 83       	st	Z, r22
 36a:	31 97       	sbiw	r30, 0x01	; 1
 36c:	64 e0       	ldi	r22, 0x04	; 4
 36e:	60 83       	st	Z, r22
 370:	31 97       	sbiw	r30, 0x01	; 1
 372:	65 e0       	ldi	r22, 0x05	; 5
 374:	60 83       	st	Z, r22
 376:	31 97       	sbiw	r30, 0x01	; 1
 378:	66 e0       	ldi	r22, 0x06	; 6
 37a:	60 83       	st	Z, r22
 37c:	31 97       	sbiw	r30, 0x01	; 1
 37e:	67 e0       	ldi	r22, 0x07	; 7
 380:	60 83       	st	Z, r22
 382:	31 97       	sbiw	r30, 0x01	; 1
 384:	68 e0       	ldi	r22, 0x08	; 8
 386:	60 83       	st	Z, r22
 388:	31 97       	sbiw	r30, 0x01	; 1
 38a:	69 e0       	ldi	r22, 0x09	; 9
 38c:	60 83       	st	Z, r22
 38e:	31 97       	sbiw	r30, 0x01	; 1
 390:	60 e1       	ldi	r22, 0x10	; 16
 392:	60 83       	st	Z, r22
 394:	31 97       	sbiw	r30, 0x01	; 1
 396:	30 83       	st	Z, r19
 398:	31 97       	sbiw	r30, 0x01	; 1
 39a:	32 e1       	ldi	r19, 0x12	; 18
 39c:	30 83       	st	Z, r19
 39e:	31 97       	sbiw	r30, 0x01	; 1
 3a0:	33 e1       	ldi	r19, 0x13	; 19
 3a2:	30 83       	st	Z, r19
 3a4:	31 97       	sbiw	r30, 0x01	; 1
 3a6:	34 e1       	ldi	r19, 0x14	; 20
 3a8:	30 83       	st	Z, r19
 3aa:	31 97       	sbiw	r30, 0x01	; 1
 3ac:	35 e1       	ldi	r19, 0x15	; 21
 3ae:	30 83       	st	Z, r19
 3b0:	31 97       	sbiw	r30, 0x01	; 1
 3b2:	36 e1       	ldi	r19, 0x16	; 22
 3b4:	30 83       	st	Z, r19
 3b6:	31 97       	sbiw	r30, 0x01	; 1
 3b8:	37 e1       	ldi	r19, 0x17	; 23
 3ba:	30 83       	st	Z, r19
 3bc:	31 97       	sbiw	r30, 0x01	; 1
 3be:	38 e1       	ldi	r19, 0x18	; 24
 3c0:	30 83       	st	Z, r19
 3c2:	31 97       	sbiw	r30, 0x01	; 1
 3c4:	39 e1       	ldi	r19, 0x19	; 25
 3c6:	30 83       	st	Z, r19
 3c8:	31 97       	sbiw	r30, 0x01	; 1
 3ca:	30 e2       	ldi	r19, 0x20	; 32
 3cc:	30 83       	st	Z, r19
 3ce:	31 97       	sbiw	r30, 0x01	; 1
 3d0:	31 e2       	ldi	r19, 0x21	; 33
 3d2:	30 83       	st	Z, r19
 3d4:	31 97       	sbiw	r30, 0x01	; 1
 3d6:	20 83       	st	Z, r18
 3d8:	31 97       	sbiw	r30, 0x01	; 1
 3da:	23 e2       	ldi	r18, 0x23	; 35
 3dc:	20 83       	st	Z, r18
 3de:	31 97       	sbiw	r30, 0x01	; 1
 3e0:	40 83       	st	Z, r20
 3e2:	31 97       	sbiw	r30, 0x01	; 1
 3e4:	50 83       	st	Z, r21
 3e6:	31 97       	sbiw	r30, 0x01	; 1
 3e8:	26 e2       	ldi	r18, 0x26	; 38
 3ea:	20 83       	st	Z, r18
 3ec:	31 97       	sbiw	r30, 0x01	; 1
 3ee:	27 e2       	ldi	r18, 0x27	; 39
 3f0:	20 83       	st	Z, r18
 3f2:	31 97       	sbiw	r30, 0x01	; 1
 3f4:	28 e2       	ldi	r18, 0x28	; 40
 3f6:	20 83       	st	Z, r18
 3f8:	31 97       	sbiw	r30, 0x01	; 1
 3fa:	29 e2       	ldi	r18, 0x29	; 41
 3fc:	20 83       	st	Z, r18
 3fe:	31 97       	sbiw	r30, 0x01	; 1
 400:	20 e3       	ldi	r18, 0x30	; 48
 402:	20 83       	st	Z, r18
 404:	31 97       	sbiw	r30, 0x01	; 1
 406:	21 e3       	ldi	r18, 0x31	; 49
 408:	20 83       	st	Z, r18
 40a:	86 97       	sbiw	r24, 0x26	; 38
 40c:	08 95       	ret

0000040e <xPortStartScheduler>:
 40e:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
 412:	8c e7       	ldi	r24, 0x7C	; 124
 414:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
 418:	8b e0       	ldi	r24, 0x0B	; 11
 41a:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
 41e:	ef e6       	ldi	r30, 0x6F	; 111
 420:	f0 e0       	ldi	r31, 0x00	; 0
 422:	80 81       	ld	r24, Z
 424:	82 60       	ori	r24, 0x02	; 2
 426:	80 83       	st	Z, r24
 428:	a0 91 57 07 	lds	r26, 0x0757	; 0x800757 <pxCurrentTCB>
 42c:	b0 91 58 07 	lds	r27, 0x0758	; 0x800758 <pxCurrentTCB+0x1>
 430:	cd 91       	ld	r28, X+
 432:	cd bf       	out	0x3d, r28	; 61
 434:	dd 91       	ld	r29, X+
 436:	de bf       	out	0x3e, r29	; 62
 438:	ff 91       	pop	r31
 43a:	ef 91       	pop	r30
 43c:	df 91       	pop	r29
 43e:	cf 91       	pop	r28
 440:	bf 91       	pop	r27
 442:	af 91       	pop	r26
 444:	9f 91       	pop	r25
 446:	8f 91       	pop	r24
 448:	7f 91       	pop	r23
 44a:	6f 91       	pop	r22
 44c:	5f 91       	pop	r21
 44e:	4f 91       	pop	r20
 450:	3f 91       	pop	r19
 452:	2f 91       	pop	r18
 454:	1f 91       	pop	r17
 456:	0f 91       	pop	r16
 458:	ff 90       	pop	r15
 45a:	ef 90       	pop	r14
 45c:	df 90       	pop	r13
 45e:	cf 90       	pop	r12
 460:	bf 90       	pop	r11
 462:	af 90       	pop	r10
 464:	9f 90       	pop	r9
 466:	8f 90       	pop	r8
 468:	7f 90       	pop	r7
 46a:	6f 90       	pop	r6
 46c:	5f 90       	pop	r5
 46e:	4f 90       	pop	r4
 470:	3f 90       	pop	r3
 472:	2f 90       	pop	r2
 474:	1f 90       	pop	r1
 476:	0f 90       	pop	r0
 478:	0f be       	out	0x3f, r0	; 63
 47a:	0f 90       	pop	r0
 47c:	08 95       	ret
 47e:	81 e0       	ldi	r24, 0x01	; 1
 480:	08 95       	ret

00000482 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
 482:	0f 92       	push	r0
 484:	0f b6       	in	r0, 0x3f	; 63
 486:	f8 94       	cli
 488:	0f 92       	push	r0
 48a:	1f 92       	push	r1
 48c:	11 24       	eor	r1, r1
 48e:	2f 92       	push	r2
 490:	3f 92       	push	r3
 492:	4f 92       	push	r4
 494:	5f 92       	push	r5
 496:	6f 92       	push	r6
 498:	7f 92       	push	r7
 49a:	8f 92       	push	r8
 49c:	9f 92       	push	r9
 49e:	af 92       	push	r10
 4a0:	bf 92       	push	r11
 4a2:	cf 92       	push	r12
 4a4:	df 92       	push	r13
 4a6:	ef 92       	push	r14
 4a8:	ff 92       	push	r15
 4aa:	0f 93       	push	r16
 4ac:	1f 93       	push	r17
 4ae:	2f 93       	push	r18
 4b0:	3f 93       	push	r19
 4b2:	4f 93       	push	r20
 4b4:	5f 93       	push	r21
 4b6:	6f 93       	push	r22
 4b8:	7f 93       	push	r23
 4ba:	8f 93       	push	r24
 4bc:	9f 93       	push	r25
 4be:	af 93       	push	r26
 4c0:	bf 93       	push	r27
 4c2:	cf 93       	push	r28
 4c4:	df 93       	push	r29
 4c6:	ef 93       	push	r30
 4c8:	ff 93       	push	r31
 4ca:	a0 91 57 07 	lds	r26, 0x0757	; 0x800757 <pxCurrentTCB>
 4ce:	b0 91 58 07 	lds	r27, 0x0758	; 0x800758 <pxCurrentTCB+0x1>
 4d2:	0d b6       	in	r0, 0x3d	; 61
 4d4:	0d 92       	st	X+, r0
 4d6:	0e b6       	in	r0, 0x3e	; 62
 4d8:	0d 92       	st	X+, r0
	vTaskSwitchContext();
 4da:	70 d3       	rcall	.+1760   	; 0xbbc <vTaskSwitchContext>
	portRESTORE_CONTEXT();
 4dc:	a0 91 57 07 	lds	r26, 0x0757	; 0x800757 <pxCurrentTCB>
 4e0:	b0 91 58 07 	lds	r27, 0x0758	; 0x800758 <pxCurrentTCB+0x1>
 4e4:	cd 91       	ld	r28, X+
 4e6:	cd bf       	out	0x3d, r28	; 61
 4e8:	dd 91       	ld	r29, X+
 4ea:	de bf       	out	0x3e, r29	; 62
 4ec:	ff 91       	pop	r31
 4ee:	ef 91       	pop	r30
 4f0:	df 91       	pop	r29
 4f2:	cf 91       	pop	r28
 4f4:	bf 91       	pop	r27
 4f6:	af 91       	pop	r26
 4f8:	9f 91       	pop	r25
 4fa:	8f 91       	pop	r24
 4fc:	7f 91       	pop	r23
 4fe:	6f 91       	pop	r22
 500:	5f 91       	pop	r21
 502:	4f 91       	pop	r20
 504:	3f 91       	pop	r19
 506:	2f 91       	pop	r18
 508:	1f 91       	pop	r17
 50a:	0f 91       	pop	r16
 50c:	ff 90       	pop	r15
 50e:	ef 90       	pop	r14
 510:	df 90       	pop	r13
 512:	cf 90       	pop	r12
 514:	bf 90       	pop	r11
 516:	af 90       	pop	r10
 518:	9f 90       	pop	r9
 51a:	8f 90       	pop	r8
 51c:	7f 90       	pop	r7
 51e:	6f 90       	pop	r6
 520:	5f 90       	pop	r5
 522:	4f 90       	pop	r4
 524:	3f 90       	pop	r3
 526:	2f 90       	pop	r2
 528:	1f 90       	pop	r1
 52a:	0f 90       	pop	r0
 52c:	0f be       	out	0x3f, r0	; 63
 52e:	0f 90       	pop	r0

	asm volatile ( "ret" );
 530:	08 95       	ret

00000532 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
 532:	0f 92       	push	r0
 534:	0f b6       	in	r0, 0x3f	; 63
 536:	f8 94       	cli
 538:	0f 92       	push	r0
 53a:	1f 92       	push	r1
 53c:	11 24       	eor	r1, r1
 53e:	2f 92       	push	r2
 540:	3f 92       	push	r3
 542:	4f 92       	push	r4
 544:	5f 92       	push	r5
 546:	6f 92       	push	r6
 548:	7f 92       	push	r7
 54a:	8f 92       	push	r8
 54c:	9f 92       	push	r9
 54e:	af 92       	push	r10
 550:	bf 92       	push	r11
 552:	cf 92       	push	r12
 554:	df 92       	push	r13
 556:	ef 92       	push	r14
 558:	ff 92       	push	r15
 55a:	0f 93       	push	r16
 55c:	1f 93       	push	r17
 55e:	2f 93       	push	r18
 560:	3f 93       	push	r19
 562:	4f 93       	push	r20
 564:	5f 93       	push	r21
 566:	6f 93       	push	r22
 568:	7f 93       	push	r23
 56a:	8f 93       	push	r24
 56c:	9f 93       	push	r25
 56e:	af 93       	push	r26
 570:	bf 93       	push	r27
 572:	cf 93       	push	r28
 574:	df 93       	push	r29
 576:	ef 93       	push	r30
 578:	ff 93       	push	r31
 57a:	a0 91 57 07 	lds	r26, 0x0757	; 0x800757 <pxCurrentTCB>
 57e:	b0 91 58 07 	lds	r27, 0x0758	; 0x800758 <pxCurrentTCB+0x1>
 582:	0d b6       	in	r0, 0x3d	; 61
 584:	0d 92       	st	X+, r0
 586:	0e b6       	in	r0, 0x3e	; 62
 588:	0d 92       	st	X+, r0
	vTaskIncrementTick();
 58a:	85 d1       	rcall	.+778    	; 0x896 <vTaskIncrementTick>
	vTaskSwitchContext();
 58c:	17 d3       	rcall	.+1582   	; 0xbbc <vTaskSwitchContext>
	portRESTORE_CONTEXT();
 58e:	a0 91 57 07 	lds	r26, 0x0757	; 0x800757 <pxCurrentTCB>
 592:	b0 91 58 07 	lds	r27, 0x0758	; 0x800758 <pxCurrentTCB+0x1>
 596:	cd 91       	ld	r28, X+
 598:	cd bf       	out	0x3d, r28	; 61
 59a:	dd 91       	ld	r29, X+
 59c:	de bf       	out	0x3e, r29	; 62
 59e:	ff 91       	pop	r31
 5a0:	ef 91       	pop	r30
 5a2:	df 91       	pop	r29
 5a4:	cf 91       	pop	r28
 5a6:	bf 91       	pop	r27
 5a8:	af 91       	pop	r26
 5aa:	9f 91       	pop	r25
 5ac:	8f 91       	pop	r24
 5ae:	7f 91       	pop	r23
 5b0:	6f 91       	pop	r22
 5b2:	5f 91       	pop	r21
 5b4:	4f 91       	pop	r20
 5b6:	3f 91       	pop	r19
 5b8:	2f 91       	pop	r18
 5ba:	1f 91       	pop	r17
 5bc:	0f 91       	pop	r16
 5be:	ff 90       	pop	r15
 5c0:	ef 90       	pop	r14
 5c2:	df 90       	pop	r13
 5c4:	cf 90       	pop	r12
 5c6:	bf 90       	pop	r11
 5c8:	af 90       	pop	r10
 5ca:	9f 90       	pop	r9
 5cc:	8f 90       	pop	r8
 5ce:	7f 90       	pop	r7
 5d0:	6f 90       	pop	r6
 5d2:	5f 90       	pop	r5
 5d4:	4f 90       	pop	r4
 5d6:	3f 90       	pop	r3
 5d8:	2f 90       	pop	r2
 5da:	1f 90       	pop	r1
 5dc:	0f 90       	pop	r0
 5de:	0f be       	out	0x3f, r0	; 63
 5e0:	0f 90       	pop	r0

	asm volatile ( "ret" );
 5e2:	08 95       	ret

000005e4 <__vector_13>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
 5e4:	a6 df       	rcall	.-180    	; 0x532 <vPortYieldFromTick>
		asm volatile ( "reti" );
 5e6:	18 95       	reti

000005e8 <prvAddCurrentTaskToDelayedList>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
 5e8:	cf 93       	push	r28
 5ea:	df 93       	push	r29
 5ec:	ec 01       	movw	r28, r24
 5ee:	e0 91 57 07 	lds	r30, 0x0757	; 0x800757 <pxCurrentTCB>
 5f2:	f0 91 58 07 	lds	r31, 0x0758	; 0x800758 <pxCurrentTCB+0x1>
 5f6:	93 83       	std	Z+3, r25	; 0x03
 5f8:	82 83       	std	Z+2, r24	; 0x02
 5fa:	80 91 07 07 	lds	r24, 0x0707	; 0x800707 <xTickCount>
 5fe:	90 91 08 07 	lds	r25, 0x0708	; 0x800708 <xTickCount+0x1>
 602:	c8 17       	cp	r28, r24
 604:	d9 07       	cpc	r29, r25
 606:	60 f4       	brcc	.+24     	; 0x620 <prvAddCurrentTaskToDelayedList+0x38>
 608:	60 91 57 07 	lds	r22, 0x0757	; 0x800757 <pxCurrentTCB>
 60c:	70 91 58 07 	lds	r23, 0x0758	; 0x800758 <pxCurrentTCB+0x1>
 610:	80 91 1d 07 	lds	r24, 0x071D	; 0x80071d <pxOverflowDelayedTaskList>
 614:	90 91 1e 07 	lds	r25, 0x071E	; 0x80071e <pxOverflowDelayedTaskList+0x1>
 618:	6e 5f       	subi	r22, 0xFE	; 254
 61a:	7f 4f       	sbci	r23, 0xFF	; 255
 61c:	b3 dd       	rcall	.-1178   	; 0x184 <vListInsert>
 61e:	16 c0       	rjmp	.+44     	; 0x64c <prvAddCurrentTaskToDelayedList+0x64>
 620:	60 91 57 07 	lds	r22, 0x0757	; 0x800757 <pxCurrentTCB>
 624:	70 91 58 07 	lds	r23, 0x0758	; 0x800758 <pxCurrentTCB+0x1>
 628:	80 91 1f 07 	lds	r24, 0x071F	; 0x80071f <pxDelayedTaskList>
 62c:	90 91 20 07 	lds	r25, 0x0720	; 0x800720 <pxDelayedTaskList+0x1>
 630:	6e 5f       	subi	r22, 0xFE	; 254
 632:	7f 4f       	sbci	r23, 0xFF	; 255
 634:	a7 dd       	rcall	.-1202   	; 0x184 <vListInsert>
 636:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
 63a:	90 91 01 01 	lds	r25, 0x0101	; 0x800101 <__data_start+0x1>
 63e:	c8 17       	cp	r28, r24
 640:	d9 07       	cpc	r29, r25
 642:	20 f4       	brcc	.+8      	; 0x64c <prvAddCurrentTaskToDelayedList+0x64>
 644:	d0 93 01 01 	sts	0x0101, r29	; 0x800101 <__data_start+0x1>
 648:	c0 93 00 01 	sts	0x0100, r28	; 0x800100 <__data_start>
 64c:	df 91       	pop	r29
 64e:	cf 91       	pop	r28
 650:	08 95       	ret

00000652 <xTaskGenericCreate>:
 652:	4f 92       	push	r4
 654:	5f 92       	push	r5
 656:	6f 92       	push	r6
 658:	7f 92       	push	r7
 65a:	8f 92       	push	r8
 65c:	9f 92       	push	r9
 65e:	af 92       	push	r10
 660:	bf 92       	push	r11
 662:	cf 92       	push	r12
 664:	df 92       	push	r13
 666:	ef 92       	push	r14
 668:	ff 92       	push	r15
 66a:	0f 93       	push	r16
 66c:	1f 93       	push	r17
 66e:	cf 93       	push	r28
 670:	df 93       	push	r29
 672:	5c 01       	movw	r10, r24
 674:	4b 01       	movw	r8, r22
 676:	3a 01       	movw	r6, r20
 678:	29 01       	movw	r4, r18
 67a:	81 e2       	ldi	r24, 0x21	; 33
 67c:	90 e0       	ldi	r25, 0x00	; 0
 67e:	24 dd       	rcall	.-1464   	; 0xc8 <pvPortMalloc>
 680:	ec 01       	movw	r28, r24
 682:	89 2b       	or	r24, r25
 684:	09 f4       	brne	.+2      	; 0x688 <xTaskGenericCreate+0x36>
 686:	c6 c0       	rjmp	.+396    	; 0x814 <xTaskGenericCreate+0x1c2>
 688:	c1 14       	cp	r12, r1
 68a:	d1 04       	cpc	r13, r1
 68c:	09 f0       	breq	.+2      	; 0x690 <xTaskGenericCreate+0x3e>
 68e:	be c0       	rjmp	.+380    	; 0x80c <xTaskGenericCreate+0x1ba>
 690:	c3 01       	movw	r24, r6
 692:	1a dd       	rcall	.-1484   	; 0xc8 <pvPortMalloc>
 694:	98 8f       	std	Y+24, r25	; 0x18
 696:	8f 8b       	std	Y+23, r24	; 0x17
 698:	00 97       	sbiw	r24, 0x00	; 0
 69a:	19 f4       	brne	.+6      	; 0x6a2 <xTaskGenericCreate+0x50>
 69c:	ce 01       	movw	r24, r28
 69e:	38 dd       	rcall	.-1424   	; 0x110 <vPortFree>
 6a0:	b9 c0       	rjmp	.+370    	; 0x814 <xTaskGenericCreate+0x1c2>
 6a2:	a3 01       	movw	r20, r6
 6a4:	65 ea       	ldi	r22, 0xA5	; 165
 6a6:	70 e0       	ldi	r23, 0x00	; 0
 6a8:	f5 d2       	rcall	.+1514   	; 0xc94 <memset>
 6aa:	93 01       	movw	r18, r6
 6ac:	21 50       	subi	r18, 0x01	; 1
 6ae:	31 09       	sbc	r19, r1
 6b0:	8f 89       	ldd	r24, Y+23	; 0x17
 6b2:	98 8d       	ldd	r25, Y+24	; 0x18
 6b4:	3c 01       	movw	r6, r24
 6b6:	62 0e       	add	r6, r18
 6b8:	73 1e       	adc	r7, r19
 6ba:	48 e0       	ldi	r20, 0x08	; 8
 6bc:	50 e0       	ldi	r21, 0x00	; 0
 6be:	b4 01       	movw	r22, r8
 6c0:	ce 01       	movw	r24, r28
 6c2:	49 96       	adiw	r24, 0x19	; 25
 6c4:	ee d2       	rcall	.+1500   	; 0xca2 <strncpy>
 6c6:	18 a2       	std	Y+32, r1	; 0x20
 6c8:	10 2f       	mov	r17, r16
 6ca:	04 30       	cpi	r16, 0x04	; 4
 6cc:	08 f0       	brcs	.+2      	; 0x6d0 <xTaskGenericCreate+0x7e>
 6ce:	13 e0       	ldi	r17, 0x03	; 3
 6d0:	1e 8b       	std	Y+22, r17	; 0x16
 6d2:	6e 01       	movw	r12, r28
 6d4:	82 e0       	ldi	r24, 0x02	; 2
 6d6:	c8 0e       	add	r12, r24
 6d8:	d1 1c       	adc	r13, r1
 6da:	c6 01       	movw	r24, r12
 6dc:	28 dd       	rcall	.-1456   	; 0x12e <vListInitialiseItem>
 6de:	ce 01       	movw	r24, r28
 6e0:	0c 96       	adiw	r24, 0x0c	; 12
 6e2:	25 dd       	rcall	.-1462   	; 0x12e <vListInitialiseItem>
 6e4:	d9 87       	std	Y+9, r29	; 0x09
 6e6:	c8 87       	std	Y+8, r28	; 0x08
 6e8:	84 e0       	ldi	r24, 0x04	; 4
 6ea:	90 e0       	ldi	r25, 0x00	; 0
 6ec:	81 1b       	sub	r24, r17
 6ee:	91 09       	sbc	r25, r1
 6f0:	9d 87       	std	Y+13, r25	; 0x0d
 6f2:	8c 87       	std	Y+12, r24	; 0x0c
 6f4:	db 8b       	std	Y+19, r29	; 0x13
 6f6:	ca 8b       	std	Y+18, r28	; 0x12
 6f8:	a2 01       	movw	r20, r4
 6fa:	b5 01       	movw	r22, r10
 6fc:	c3 01       	movw	r24, r6
 6fe:	1b de       	rcall	.-970    	; 0x336 <pxPortInitialiseStack>
 700:	99 83       	std	Y+1, r25	; 0x01
 702:	88 83       	st	Y, r24
 704:	e1 14       	cp	r14, r1
 706:	f1 04       	cpc	r15, r1
 708:	19 f0       	breq	.+6      	; 0x710 <xTaskGenericCreate+0xbe>
 70a:	f7 01       	movw	r30, r14
 70c:	d1 83       	std	Z+1, r29	; 0x01
 70e:	c0 83       	st	Z, r28
 710:	0f b6       	in	r0, 0x3f	; 63
 712:	f8 94       	cli
 714:	0f 92       	push	r0
 716:	80 91 09 07 	lds	r24, 0x0709	; 0x800709 <uxCurrentNumberOfTasks>
 71a:	8f 5f       	subi	r24, 0xFF	; 255
 71c:	80 93 09 07 	sts	0x0709, r24	; 0x800709 <uxCurrentNumberOfTasks>
 720:	80 91 57 07 	lds	r24, 0x0757	; 0x800757 <pxCurrentTCB>
 724:	90 91 58 07 	lds	r25, 0x0758	; 0x800758 <pxCurrentTCB+0x1>
 728:	89 2b       	or	r24, r25
 72a:	69 f5       	brne	.+90     	; 0x786 <xTaskGenericCreate+0x134>
 72c:	d0 93 58 07 	sts	0x0758, r29	; 0x800758 <pxCurrentTCB+0x1>
 730:	c0 93 57 07 	sts	0x0757, r28	; 0x800757 <pxCurrentTCB>
 734:	80 91 09 07 	lds	r24, 0x0709	; 0x800709 <uxCurrentNumberOfTasks>
 738:	81 30       	cpi	r24, 0x01	; 1
 73a:	a1 f5       	brne	.+104    	; 0x7a4 <xTaskGenericCreate+0x152>
 73c:	83 e3       	ldi	r24, 0x33	; 51
 73e:	97 e0       	ldi	r25, 0x07	; 7
 740:	e8 dc       	rcall	.-1584   	; 0x112 <vListInitialise>
 742:	8c e3       	ldi	r24, 0x3C	; 60
 744:	97 e0       	ldi	r25, 0x07	; 7
 746:	e5 dc       	rcall	.-1590   	; 0x112 <vListInitialise>
 748:	85 e4       	ldi	r24, 0x45	; 69
 74a:	97 e0       	ldi	r25, 0x07	; 7
 74c:	e2 dc       	rcall	.-1596   	; 0x112 <vListInitialise>
 74e:	8e e4       	ldi	r24, 0x4E	; 78
 750:	97 e0       	ldi	r25, 0x07	; 7
 752:	df dc       	rcall	.-1602   	; 0x112 <vListInitialise>
 754:	8a e2       	ldi	r24, 0x2A	; 42
 756:	97 e0       	ldi	r25, 0x07	; 7
 758:	dc dc       	rcall	.-1608   	; 0x112 <vListInitialise>
 75a:	81 e2       	ldi	r24, 0x21	; 33
 75c:	97 e0       	ldi	r25, 0x07	; 7
 75e:	d9 dc       	rcall	.-1614   	; 0x112 <vListInitialise>
 760:	84 e1       	ldi	r24, 0x14	; 20
 762:	97 e0       	ldi	r25, 0x07	; 7
 764:	d6 dc       	rcall	.-1620   	; 0x112 <vListInitialise>
 766:	8b e0       	ldi	r24, 0x0B	; 11
 768:	97 e0       	ldi	r25, 0x07	; 7
 76a:	d3 dc       	rcall	.-1626   	; 0x112 <vListInitialise>
 76c:	8a e2       	ldi	r24, 0x2A	; 42
 76e:	97 e0       	ldi	r25, 0x07	; 7
 770:	90 93 20 07 	sts	0x0720, r25	; 0x800720 <pxDelayedTaskList+0x1>
 774:	80 93 1f 07 	sts	0x071F, r24	; 0x80071f <pxDelayedTaskList>
 778:	81 e2       	ldi	r24, 0x21	; 33
 77a:	97 e0       	ldi	r25, 0x07	; 7
 77c:	90 93 1e 07 	sts	0x071E, r25	; 0x80071e <pxOverflowDelayedTaskList+0x1>
 780:	80 93 1d 07 	sts	0x071D, r24	; 0x80071d <pxOverflowDelayedTaskList>
 784:	0f c0       	rjmp	.+30     	; 0x7a4 <xTaskGenericCreate+0x152>
 786:	80 91 04 07 	lds	r24, 0x0704	; 0x800704 <xSchedulerRunning>
 78a:	81 11       	cpse	r24, r1
 78c:	0b c0       	rjmp	.+22     	; 0x7a4 <xTaskGenericCreate+0x152>
 78e:	e0 91 57 07 	lds	r30, 0x0757	; 0x800757 <pxCurrentTCB>
 792:	f0 91 58 07 	lds	r31, 0x0758	; 0x800758 <pxCurrentTCB+0x1>
 796:	86 89       	ldd	r24, Z+22	; 0x16
 798:	08 17       	cp	r16, r24
 79a:	20 f0       	brcs	.+8      	; 0x7a4 <xTaskGenericCreate+0x152>
 79c:	d0 93 58 07 	sts	0x0758, r29	; 0x800758 <pxCurrentTCB+0x1>
 7a0:	c0 93 57 07 	sts	0x0757, r28	; 0x800757 <pxCurrentTCB>
 7a4:	8e 89       	ldd	r24, Y+22	; 0x16
 7a6:	90 91 06 07 	lds	r25, 0x0706	; 0x800706 <uxTopUsedPriority>
 7aa:	98 17       	cp	r25, r24
 7ac:	10 f4       	brcc	.+4      	; 0x7b2 <xTaskGenericCreate+0x160>
 7ae:	80 93 06 07 	sts	0x0706, r24	; 0x800706 <uxTopUsedPriority>
 7b2:	90 91 ff 06 	lds	r25, 0x06FF	; 0x8006ff <uxTaskNumber>
 7b6:	9f 5f       	subi	r25, 0xFF	; 255
 7b8:	90 93 ff 06 	sts	0x06FF, r25	; 0x8006ff <uxTaskNumber>
 7bc:	90 91 05 07 	lds	r25, 0x0705	; 0x800705 <uxTopReadyPriority>
 7c0:	98 17       	cp	r25, r24
 7c2:	10 f4       	brcc	.+4      	; 0x7c8 <xTaskGenericCreate+0x176>
 7c4:	80 93 05 07 	sts	0x0705, r24	; 0x800705 <uxTopReadyPriority>
 7c8:	90 e0       	ldi	r25, 0x00	; 0
 7ca:	9c 01       	movw	r18, r24
 7cc:	22 0f       	add	r18, r18
 7ce:	33 1f       	adc	r19, r19
 7d0:	22 0f       	add	r18, r18
 7d2:	33 1f       	adc	r19, r19
 7d4:	22 0f       	add	r18, r18
 7d6:	33 1f       	adc	r19, r19
 7d8:	82 0f       	add	r24, r18
 7da:	93 1f       	adc	r25, r19
 7dc:	b6 01       	movw	r22, r12
 7de:	8d 5c       	subi	r24, 0xCD	; 205
 7e0:	98 4f       	sbci	r25, 0xF8	; 248
 7e2:	a9 dc       	rcall	.-1710   	; 0x136 <vListInsertEnd>
 7e4:	0f 90       	pop	r0
 7e6:	0f be       	out	0x3f, r0	; 63
 7e8:	80 91 04 07 	lds	r24, 0x0704	; 0x800704 <xSchedulerRunning>
 7ec:	88 23       	and	r24, r24
 7ee:	51 f0       	breq	.+20     	; 0x804 <xTaskGenericCreate+0x1b2>
 7f0:	e0 91 57 07 	lds	r30, 0x0757	; 0x800757 <pxCurrentTCB>
 7f4:	f0 91 58 07 	lds	r31, 0x0758	; 0x800758 <pxCurrentTCB+0x1>
 7f8:	86 89       	ldd	r24, Z+22	; 0x16
 7fa:	80 17       	cp	r24, r16
 7fc:	28 f4       	brcc	.+10     	; 0x808 <xTaskGenericCreate+0x1b6>
 7fe:	41 de       	rcall	.-894    	; 0x482 <vPortYield>
 800:	81 e0       	ldi	r24, 0x01	; 1
 802:	09 c0       	rjmp	.+18     	; 0x816 <xTaskGenericCreate+0x1c4>
 804:	81 e0       	ldi	r24, 0x01	; 1
 806:	07 c0       	rjmp	.+14     	; 0x816 <xTaskGenericCreate+0x1c4>
 808:	81 e0       	ldi	r24, 0x01	; 1
 80a:	05 c0       	rjmp	.+10     	; 0x816 <xTaskGenericCreate+0x1c4>
 80c:	d8 8e       	std	Y+24, r13	; 0x18
 80e:	cf 8a       	std	Y+23, r12	; 0x17
 810:	c6 01       	movw	r24, r12
 812:	47 cf       	rjmp	.-370    	; 0x6a2 <xTaskGenericCreate+0x50>
 814:	8f ef       	ldi	r24, 0xFF	; 255
 816:	df 91       	pop	r29
 818:	cf 91       	pop	r28
 81a:	1f 91       	pop	r17
 81c:	0f 91       	pop	r16
 81e:	ff 90       	pop	r15
 820:	ef 90       	pop	r14
 822:	df 90       	pop	r13
 824:	cf 90       	pop	r12
 826:	bf 90       	pop	r11
 828:	af 90       	pop	r10
 82a:	9f 90       	pop	r9
 82c:	8f 90       	pop	r8
 82e:	7f 90       	pop	r7
 830:	6f 90       	pop	r6
 832:	5f 90       	pop	r5
 834:	4f 90       	pop	r4
 836:	08 95       	ret

00000838 <vTaskStartScheduler>:
 838:	af 92       	push	r10
 83a:	bf 92       	push	r11
 83c:	cf 92       	push	r12
 83e:	df 92       	push	r13
 840:	ef 92       	push	r14
 842:	ff 92       	push	r15
 844:	0f 93       	push	r16
 846:	a1 2c       	mov	r10, r1
 848:	b1 2c       	mov	r11, r1
 84a:	c1 2c       	mov	r12, r1
 84c:	d1 2c       	mov	r13, r1
 84e:	e1 2c       	mov	r14, r1
 850:	f1 2c       	mov	r15, r1
 852:	00 e0       	ldi	r16, 0x00	; 0
 854:	20 e0       	ldi	r18, 0x00	; 0
 856:	30 e0       	ldi	r19, 0x00	; 0
 858:	45 e5       	ldi	r20, 0x55	; 85
 85a:	50 e0       	ldi	r21, 0x00	; 0
 85c:	6a e1       	ldi	r22, 0x1A	; 26
 85e:	71 e0       	ldi	r23, 0x01	; 1
 860:	88 ea       	ldi	r24, 0xA8	; 168
 862:	95 e0       	ldi	r25, 0x05	; 5
 864:	f6 de       	rcall	.-532    	; 0x652 <xTaskGenericCreate>
 866:	81 30       	cpi	r24, 0x01	; 1
 868:	41 f4       	brne	.+16     	; 0x87a <vTaskStartScheduler+0x42>
 86a:	f8 94       	cli
 86c:	80 93 04 07 	sts	0x0704, r24	; 0x800704 <xSchedulerRunning>
 870:	10 92 08 07 	sts	0x0708, r1	; 0x800708 <xTickCount+0x1>
 874:	10 92 07 07 	sts	0x0707, r1	; 0x800707 <xTickCount>
 878:	ca dd       	rcall	.-1132   	; 0x40e <xPortStartScheduler>
 87a:	0f 91       	pop	r16
 87c:	ff 90       	pop	r15
 87e:	ef 90       	pop	r14
 880:	df 90       	pop	r13
 882:	cf 90       	pop	r12
 884:	bf 90       	pop	r11
 886:	af 90       	pop	r10
 888:	08 95       	ret

0000088a <vTaskSuspendAll>:
 88a:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <uxSchedulerSuspended>
 88e:	8f 5f       	subi	r24, 0xFF	; 255
 890:	80 93 03 07 	sts	0x0703, r24	; 0x800703 <uxSchedulerSuspended>
 894:	08 95       	ret

00000896 <vTaskIncrementTick>:
 896:	0f 93       	push	r16
 898:	1f 93       	push	r17
 89a:	cf 93       	push	r28
 89c:	df 93       	push	r29
 89e:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <uxSchedulerSuspended>
 8a2:	81 11       	cpse	r24, r1
 8a4:	af c0       	rjmp	.+350    	; 0xa04 <vTaskIncrementTick+0x16e>
 8a6:	80 91 07 07 	lds	r24, 0x0707	; 0x800707 <xTickCount>
 8aa:	90 91 08 07 	lds	r25, 0x0708	; 0x800708 <xTickCount+0x1>
 8ae:	01 96       	adiw	r24, 0x01	; 1
 8b0:	90 93 08 07 	sts	0x0708, r25	; 0x800708 <xTickCount+0x1>
 8b4:	80 93 07 07 	sts	0x0707, r24	; 0x800707 <xTickCount>
 8b8:	80 91 07 07 	lds	r24, 0x0707	; 0x800707 <xTickCount>
 8bc:	90 91 08 07 	lds	r25, 0x0708	; 0x800708 <xTickCount+0x1>
 8c0:	89 2b       	or	r24, r25
 8c2:	99 f5       	brne	.+102    	; 0x92a <vTaskIncrementTick+0x94>
 8c4:	80 91 1f 07 	lds	r24, 0x071F	; 0x80071f <pxDelayedTaskList>
 8c8:	90 91 20 07 	lds	r25, 0x0720	; 0x800720 <pxDelayedTaskList+0x1>
 8cc:	20 91 1d 07 	lds	r18, 0x071D	; 0x80071d <pxOverflowDelayedTaskList>
 8d0:	30 91 1e 07 	lds	r19, 0x071E	; 0x80071e <pxOverflowDelayedTaskList+0x1>
 8d4:	30 93 20 07 	sts	0x0720, r19	; 0x800720 <pxDelayedTaskList+0x1>
 8d8:	20 93 1f 07 	sts	0x071F, r18	; 0x80071f <pxDelayedTaskList>
 8dc:	90 93 1e 07 	sts	0x071E, r25	; 0x80071e <pxOverflowDelayedTaskList+0x1>
 8e0:	80 93 1d 07 	sts	0x071D, r24	; 0x80071d <pxOverflowDelayedTaskList>
 8e4:	80 91 00 07 	lds	r24, 0x0700	; 0x800700 <xNumOfOverflows>
 8e8:	8f 5f       	subi	r24, 0xFF	; 255
 8ea:	80 93 00 07 	sts	0x0700, r24	; 0x800700 <xNumOfOverflows>
 8ee:	e0 91 1f 07 	lds	r30, 0x071F	; 0x80071f <pxDelayedTaskList>
 8f2:	f0 91 20 07 	lds	r31, 0x0720	; 0x800720 <pxDelayedTaskList+0x1>
 8f6:	80 81       	ld	r24, Z
 8f8:	81 11       	cpse	r24, r1
 8fa:	07 c0       	rjmp	.+14     	; 0x90a <vTaskIncrementTick+0x74>
 8fc:	8f ef       	ldi	r24, 0xFF	; 255
 8fe:	9f ef       	ldi	r25, 0xFF	; 255
 900:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
 904:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
 908:	10 c0       	rjmp	.+32     	; 0x92a <vTaskIncrementTick+0x94>
 90a:	e0 91 1f 07 	lds	r30, 0x071F	; 0x80071f <pxDelayedTaskList>
 90e:	f0 91 20 07 	lds	r31, 0x0720	; 0x800720 <pxDelayedTaskList+0x1>
 912:	05 80       	ldd	r0, Z+5	; 0x05
 914:	f6 81       	ldd	r31, Z+6	; 0x06
 916:	e0 2d       	mov	r30, r0
 918:	06 80       	ldd	r0, Z+6	; 0x06
 91a:	f7 81       	ldd	r31, Z+7	; 0x07
 91c:	e0 2d       	mov	r30, r0
 91e:	82 81       	ldd	r24, Z+2	; 0x02
 920:	93 81       	ldd	r25, Z+3	; 0x03
 922:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
 926:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
 92a:	20 91 07 07 	lds	r18, 0x0707	; 0x800707 <xTickCount>
 92e:	30 91 08 07 	lds	r19, 0x0708	; 0x800708 <xTickCount+0x1>
 932:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
 936:	90 91 01 01 	lds	r25, 0x0101	; 0x800101 <__data_start+0x1>
 93a:	28 17       	cp	r18, r24
 93c:	39 07       	cpc	r19, r25
 93e:	08 f4       	brcc	.+2      	; 0x942 <vTaskIncrementTick+0xac>
 940:	66 c0       	rjmp	.+204    	; 0xa0e <vTaskIncrementTick+0x178>
 942:	e0 91 1f 07 	lds	r30, 0x071F	; 0x80071f <pxDelayedTaskList>
 946:	f0 91 20 07 	lds	r31, 0x0720	; 0x800720 <pxDelayedTaskList+0x1>
 94a:	80 81       	ld	r24, Z
 94c:	88 23       	and	r24, r24
 94e:	99 f0       	breq	.+38     	; 0x976 <vTaskIncrementTick+0xe0>
 950:	e0 91 1f 07 	lds	r30, 0x071F	; 0x80071f <pxDelayedTaskList>
 954:	f0 91 20 07 	lds	r31, 0x0720	; 0x800720 <pxDelayedTaskList+0x1>
 958:	05 80       	ldd	r0, Z+5	; 0x05
 95a:	f6 81       	ldd	r31, Z+6	; 0x06
 95c:	e0 2d       	mov	r30, r0
 95e:	c6 81       	ldd	r28, Z+6	; 0x06
 960:	d7 81       	ldd	r29, Z+7	; 0x07
 962:	8a 81       	ldd	r24, Y+2	; 0x02
 964:	9b 81       	ldd	r25, Y+3	; 0x03
 966:	20 91 07 07 	lds	r18, 0x0707	; 0x800707 <xTickCount>
 96a:	30 91 08 07 	lds	r19, 0x0708	; 0x800708 <xTickCount+0x1>
 96e:	28 17       	cp	r18, r24
 970:	39 07       	cpc	r19, r25
 972:	f8 f4       	brcc	.+62     	; 0x9b2 <vTaskIncrementTick+0x11c>
 974:	19 c0       	rjmp	.+50     	; 0x9a8 <vTaskIncrementTick+0x112>
 976:	8f ef       	ldi	r24, 0xFF	; 255
 978:	9f ef       	ldi	r25, 0xFF	; 255
 97a:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
 97e:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
 982:	45 c0       	rjmp	.+138    	; 0xa0e <vTaskIncrementTick+0x178>
 984:	e0 91 1f 07 	lds	r30, 0x071F	; 0x80071f <pxDelayedTaskList>
 988:	f0 91 20 07 	lds	r31, 0x0720	; 0x800720 <pxDelayedTaskList+0x1>
 98c:	05 80       	ldd	r0, Z+5	; 0x05
 98e:	f6 81       	ldd	r31, Z+6	; 0x06
 990:	e0 2d       	mov	r30, r0
 992:	c6 81       	ldd	r28, Z+6	; 0x06
 994:	d7 81       	ldd	r29, Z+7	; 0x07
 996:	8a 81       	ldd	r24, Y+2	; 0x02
 998:	9b 81       	ldd	r25, Y+3	; 0x03
 99a:	20 91 07 07 	lds	r18, 0x0707	; 0x800707 <xTickCount>
 99e:	30 91 08 07 	lds	r19, 0x0708	; 0x800708 <xTickCount+0x1>
 9a2:	28 17       	cp	r18, r24
 9a4:	39 07       	cpc	r19, r25
 9a6:	28 f4       	brcc	.+10     	; 0x9b2 <vTaskIncrementTick+0x11c>
 9a8:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
 9ac:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
 9b0:	2e c0       	rjmp	.+92     	; 0xa0e <vTaskIncrementTick+0x178>
 9b2:	8e 01       	movw	r16, r28
 9b4:	0e 5f       	subi	r16, 0xFE	; 254
 9b6:	1f 4f       	sbci	r17, 0xFF	; 255
 9b8:	c8 01       	movw	r24, r16
 9ba:	1f dc       	rcall	.-1986   	; 0x1fa <vListRemove>
 9bc:	8c 89       	ldd	r24, Y+20	; 0x14
 9be:	9d 89       	ldd	r25, Y+21	; 0x15
 9c0:	89 2b       	or	r24, r25
 9c2:	19 f0       	breq	.+6      	; 0x9ca <vTaskIncrementTick+0x134>
 9c4:	ce 01       	movw	r24, r28
 9c6:	0c 96       	adiw	r24, 0x0c	; 12
 9c8:	18 dc       	rcall	.-2000   	; 0x1fa <vListRemove>
 9ca:	2e 89       	ldd	r18, Y+22	; 0x16
 9cc:	80 91 05 07 	lds	r24, 0x0705	; 0x800705 <uxTopReadyPriority>
 9d0:	82 17       	cp	r24, r18
 9d2:	10 f4       	brcc	.+4      	; 0x9d8 <vTaskIncrementTick+0x142>
 9d4:	20 93 05 07 	sts	0x0705, r18	; 0x800705 <uxTopReadyPriority>
 9d8:	30 e0       	ldi	r19, 0x00	; 0
 9da:	c9 01       	movw	r24, r18
 9dc:	88 0f       	add	r24, r24
 9de:	99 1f       	adc	r25, r25
 9e0:	88 0f       	add	r24, r24
 9e2:	99 1f       	adc	r25, r25
 9e4:	88 0f       	add	r24, r24
 9e6:	99 1f       	adc	r25, r25
 9e8:	82 0f       	add	r24, r18
 9ea:	93 1f       	adc	r25, r19
 9ec:	b8 01       	movw	r22, r16
 9ee:	8d 5c       	subi	r24, 0xCD	; 205
 9f0:	98 4f       	sbci	r25, 0xF8	; 248
 9f2:	a1 db       	rcall	.-2238   	; 0x136 <vListInsertEnd>
 9f4:	e0 91 1f 07 	lds	r30, 0x071F	; 0x80071f <pxDelayedTaskList>
 9f8:	f0 91 20 07 	lds	r31, 0x0720	; 0x800720 <pxDelayedTaskList+0x1>
 9fc:	80 81       	ld	r24, Z
 9fe:	81 11       	cpse	r24, r1
 a00:	c1 cf       	rjmp	.-126    	; 0x984 <vTaskIncrementTick+0xee>
 a02:	b9 cf       	rjmp	.-142    	; 0x976 <vTaskIncrementTick+0xe0>
 a04:	80 91 02 07 	lds	r24, 0x0702	; 0x800702 <uxMissedTicks>
 a08:	8f 5f       	subi	r24, 0xFF	; 255
 a0a:	80 93 02 07 	sts	0x0702, r24	; 0x800702 <uxMissedTicks>
 a0e:	df 91       	pop	r29
 a10:	cf 91       	pop	r28
 a12:	1f 91       	pop	r17
 a14:	0f 91       	pop	r16
 a16:	08 95       	ret

00000a18 <xTaskResumeAll>:
 a18:	cf 92       	push	r12
 a1a:	df 92       	push	r13
 a1c:	ef 92       	push	r14
 a1e:	ff 92       	push	r15
 a20:	0f 93       	push	r16
 a22:	1f 93       	push	r17
 a24:	cf 93       	push	r28
 a26:	df 93       	push	r29
 a28:	0f b6       	in	r0, 0x3f	; 63
 a2a:	f8 94       	cli
 a2c:	0f 92       	push	r0
 a2e:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <uxSchedulerSuspended>
 a32:	81 50       	subi	r24, 0x01	; 1
 a34:	80 93 03 07 	sts	0x0703, r24	; 0x800703 <uxSchedulerSuspended>
 a38:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <uxSchedulerSuspended>
 a3c:	81 11       	cpse	r24, r1
 a3e:	5f c0       	rjmp	.+190    	; 0xafe <xTaskResumeAll+0xe6>
 a40:	80 91 09 07 	lds	r24, 0x0709	; 0x800709 <uxCurrentNumberOfTasks>
 a44:	81 11       	cpse	r24, r1
 a46:	2f c0       	rjmp	.+94     	; 0xaa6 <xTaskResumeAll+0x8e>
 a48:	5d c0       	rjmp	.+186    	; 0xb04 <xTaskResumeAll+0xec>
 a4a:	d7 01       	movw	r26, r14
 a4c:	15 96       	adiw	r26, 0x05	; 5
 a4e:	ed 91       	ld	r30, X+
 a50:	fc 91       	ld	r31, X
 a52:	16 97       	sbiw	r26, 0x06	; 6
 a54:	c6 81       	ldd	r28, Z+6	; 0x06
 a56:	d7 81       	ldd	r29, Z+7	; 0x07
 a58:	ce 01       	movw	r24, r28
 a5a:	0c 96       	adiw	r24, 0x0c	; 12
 a5c:	ce db       	rcall	.-2148   	; 0x1fa <vListRemove>
 a5e:	8e 01       	movw	r16, r28
 a60:	0e 5f       	subi	r16, 0xFE	; 254
 a62:	1f 4f       	sbci	r17, 0xFF	; 255
 a64:	c8 01       	movw	r24, r16
 a66:	c9 db       	rcall	.-2158   	; 0x1fa <vListRemove>
 a68:	2e 89       	ldd	r18, Y+22	; 0x16
 a6a:	80 91 05 07 	lds	r24, 0x0705	; 0x800705 <uxTopReadyPriority>
 a6e:	82 17       	cp	r24, r18
 a70:	10 f4       	brcc	.+4      	; 0xa76 <xTaskResumeAll+0x5e>
 a72:	20 93 05 07 	sts	0x0705, r18	; 0x800705 <uxTopReadyPriority>
 a76:	30 e0       	ldi	r19, 0x00	; 0
 a78:	c9 01       	movw	r24, r18
 a7a:	88 0f       	add	r24, r24
 a7c:	99 1f       	adc	r25, r25
 a7e:	88 0f       	add	r24, r24
 a80:	99 1f       	adc	r25, r25
 a82:	88 0f       	add	r24, r24
 a84:	99 1f       	adc	r25, r25
 a86:	82 0f       	add	r24, r18
 a88:	93 1f       	adc	r25, r19
 a8a:	b8 01       	movw	r22, r16
 a8c:	8d 5c       	subi	r24, 0xCD	; 205
 a8e:	98 4f       	sbci	r25, 0xF8	; 248
 a90:	52 db       	rcall	.-2396   	; 0x136 <vListInsertEnd>
 a92:	e0 91 57 07 	lds	r30, 0x0757	; 0x800757 <pxCurrentTCB>
 a96:	f0 91 58 07 	lds	r31, 0x0758	; 0x800758 <pxCurrentTCB+0x1>
 a9a:	9e 89       	ldd	r25, Y+22	; 0x16
 a9c:	86 89       	ldd	r24, Z+22	; 0x16
 a9e:	98 17       	cp	r25, r24
 aa0:	58 f0       	brcs	.+22     	; 0xab8 <xTaskResumeAll+0xa0>
 aa2:	dc 2c       	mov	r13, r12
 aa4:	09 c0       	rjmp	.+18     	; 0xab8 <xTaskResumeAll+0xa0>
 aa6:	d1 2c       	mov	r13, r1
 aa8:	0f 2e       	mov	r0, r31
 aaa:	f4 e1       	ldi	r31, 0x14	; 20
 aac:	ef 2e       	mov	r14, r31
 aae:	f7 e0       	ldi	r31, 0x07	; 7
 ab0:	ff 2e       	mov	r15, r31
 ab2:	f0 2d       	mov	r31, r0
 ab4:	cc 24       	eor	r12, r12
 ab6:	c3 94       	inc	r12
 ab8:	f7 01       	movw	r30, r14
 aba:	80 81       	ld	r24, Z
 abc:	81 11       	cpse	r24, r1
 abe:	c5 cf       	rjmp	.-118    	; 0xa4a <xTaskResumeAll+0x32>
 ac0:	80 91 02 07 	lds	r24, 0x0702	; 0x800702 <uxMissedTicks>
 ac4:	88 23       	and	r24, r24
 ac6:	79 f0       	breq	.+30     	; 0xae6 <xTaskResumeAll+0xce>
 ac8:	80 91 02 07 	lds	r24, 0x0702	; 0x800702 <uxMissedTicks>
 acc:	88 23       	and	r24, r24
 ace:	91 f0       	breq	.+36     	; 0xaf4 <xTaskResumeAll+0xdc>
 ad0:	e2 de       	rcall	.-572    	; 0x896 <vTaskIncrementTick>
 ad2:	80 91 02 07 	lds	r24, 0x0702	; 0x800702 <uxMissedTicks>
 ad6:	81 50       	subi	r24, 0x01	; 1
 ad8:	80 93 02 07 	sts	0x0702, r24	; 0x800702 <uxMissedTicks>
 adc:	80 91 02 07 	lds	r24, 0x0702	; 0x800702 <uxMissedTicks>
 ae0:	81 11       	cpse	r24, r1
 ae2:	f6 cf       	rjmp	.-20     	; 0xad0 <xTaskResumeAll+0xb8>
 ae4:	07 c0       	rjmp	.+14     	; 0xaf4 <xTaskResumeAll+0xdc>
 ae6:	f1 e0       	ldi	r31, 0x01	; 1
 ae8:	df 16       	cp	r13, r31
 aea:	21 f0       	breq	.+8      	; 0xaf4 <xTaskResumeAll+0xdc>
 aec:	80 91 01 07 	lds	r24, 0x0701	; 0x800701 <xMissedYield>
 af0:	81 30       	cpi	r24, 0x01	; 1
 af2:	39 f4       	brne	.+14     	; 0xb02 <xTaskResumeAll+0xea>
 af4:	10 92 01 07 	sts	0x0701, r1	; 0x800701 <xMissedYield>
 af8:	c4 dc       	rcall	.-1656   	; 0x482 <vPortYield>
 afa:	81 e0       	ldi	r24, 0x01	; 1
 afc:	03 c0       	rjmp	.+6      	; 0xb04 <xTaskResumeAll+0xec>
 afe:	80 e0       	ldi	r24, 0x00	; 0
 b00:	01 c0       	rjmp	.+2      	; 0xb04 <xTaskResumeAll+0xec>
 b02:	80 e0       	ldi	r24, 0x00	; 0
 b04:	0f 90       	pop	r0
 b06:	0f be       	out	0x3f, r0	; 63
 b08:	df 91       	pop	r29
 b0a:	cf 91       	pop	r28
 b0c:	1f 91       	pop	r17
 b0e:	0f 91       	pop	r16
 b10:	ff 90       	pop	r15
 b12:	ef 90       	pop	r14
 b14:	df 90       	pop	r13
 b16:	cf 90       	pop	r12
 b18:	08 95       	ret

00000b1a <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
 b1a:	cf 93       	push	r28
 b1c:	df 93       	push	r29
 b1e:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
 b20:	89 2b       	or	r24, r25
 b22:	91 f0       	breq	.+36     	; 0xb48 <vTaskDelay+0x2e>
		{
			vTaskSuspendAll();
 b24:	b2 de       	rcall	.-668    	; 0x88a <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
 b26:	80 91 07 07 	lds	r24, 0x0707	; 0x800707 <xTickCount>
 b2a:	90 91 08 07 	lds	r25, 0x0708	; 0x800708 <xTickCount+0x1>
 b2e:	c8 0f       	add	r28, r24
 b30:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 b32:	80 91 57 07 	lds	r24, 0x0757	; 0x800757 <pxCurrentTCB>
 b36:	90 91 58 07 	lds	r25, 0x0758	; 0x800758 <pxCurrentTCB+0x1>
 b3a:	02 96       	adiw	r24, 0x02	; 2
 b3c:	5e db       	rcall	.-2372   	; 0x1fa <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
 b3e:	ce 01       	movw	r24, r28
 b40:	53 dd       	rcall	.-1370   	; 0x5e8 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
 b42:	6a df       	rcall	.-300    	; 0xa18 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 b44:	81 11       	cpse	r24, r1
 b46:	01 c0       	rjmp	.+2      	; 0xb4a <vTaskDelay+0x30>
		{
			portYIELD_WITHIN_API();
 b48:	9c dc       	rcall	.-1736   	; 0x482 <vPortYield>
		}
	}
 b4a:	df 91       	pop	r29
 b4c:	cf 91       	pop	r28
 b4e:	08 95       	ret

00000b50 <prvIdleTask>:
		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 b50:	0f 2e       	mov	r0, r31
 b52:	fb e0       	ldi	r31, 0x0B	; 11
 b54:	ef 2e       	mov	r14, r31
 b56:	f7 e0       	ldi	r31, 0x07	; 7
 b58:	ff 2e       	mov	r15, r31
 b5a:	f0 2d       	mov	r31, r0

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
 b5c:	c3 e3       	ldi	r28, 0x33	; 51
 b5e:	d7 e0       	ldi	r29, 0x07	; 7
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
 b60:	80 91 0a 07 	lds	r24, 0x070A	; 0x80070a <uxTasksDeleted>
 b64:	88 23       	and	r24, r24
 b66:	29 f1       	breq	.+74     	; 0xbb2 <prvIdleTask+0x62>
		{
			vTaskSuspendAll();
 b68:	90 de       	rcall	.-736    	; 0x88a <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 b6a:	d7 01       	movw	r26, r14
 b6c:	1c 91       	ld	r17, X
			xTaskResumeAll();
 b6e:	54 df       	rcall	.-344    	; 0xa18 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
 b70:	11 23       	and	r17, r17
 b72:	f9 f0       	breq	.+62     	; 0xbb2 <prvIdleTask+0x62>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
 b74:	0f b6       	in	r0, 0x3f	; 63
 b76:	f8 94       	cli
 b78:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
 b7a:	d7 01       	movw	r26, r14
 b7c:	15 96       	adiw	r26, 0x05	; 5
 b7e:	ed 91       	ld	r30, X+
 b80:	fc 91       	ld	r31, X
 b82:	16 97       	sbiw	r26, 0x06	; 6
 b84:	06 81       	ldd	r16, Z+6	; 0x06
 b86:	17 81       	ldd	r17, Z+7	; 0x07
					vListRemove( &( pxTCB->xGenericListItem ) );
 b88:	c8 01       	movw	r24, r16
 b8a:	02 96       	adiw	r24, 0x02	; 2
 b8c:	36 db       	rcall	.-2452   	; 0x1fa <vListRemove>
					--uxCurrentNumberOfTasks;
 b8e:	80 91 09 07 	lds	r24, 0x0709	; 0x800709 <uxCurrentNumberOfTasks>
 b92:	81 50       	subi	r24, 0x01	; 1
 b94:	80 93 09 07 	sts	0x0709, r24	; 0x800709 <uxCurrentNumberOfTasks>
					--uxTasksDeleted;
 b98:	80 91 0a 07 	lds	r24, 0x070A	; 0x80070a <uxTasksDeleted>
 b9c:	81 50       	subi	r24, 0x01	; 1
 b9e:	80 93 0a 07 	sts	0x070A, r24	; 0x80070a <uxTasksDeleted>
				}
				taskEXIT_CRITICAL();
 ba2:	0f 90       	pop	r0
 ba4:	0f be       	out	0x3f, r0	; 63
		want to allocate and clean RAM statically. */
		portCLEAN_UP_TCB( pxTCB );

		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
 ba6:	f8 01       	movw	r30, r16
 ba8:	87 89       	ldd	r24, Z+23	; 0x17
 baa:	90 8d       	ldd	r25, Z+24	; 0x18
 bac:	b1 da       	rcall	.-2718   	; 0x110 <vPortFree>
		vPortFree( pxTCB );
 bae:	c8 01       	movw	r24, r16
 bb0:	af da       	rcall	.-2722   	; 0x110 <vPortFree>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
 bb2:	88 81       	ld	r24, Y
 bb4:	82 30       	cpi	r24, 0x02	; 2
 bb6:	a0 f2       	brcs	.-88     	; 0xb60 <prvIdleTask+0x10>
			{
				taskYIELD();
 bb8:	64 dc       	rcall	.-1848   	; 0x482 <vPortYield>
 bba:	d2 cf       	rjmp	.-92     	; 0xb60 <prvIdleTask+0x10>

00000bbc <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 bbc:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <uxSchedulerSuspended>
 bc0:	81 11       	cpse	r24, r1
 bc2:	13 c0       	rjmp	.+38     	; 0xbea <vTaskSwitchContext+0x2e>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 bc4:	80 91 05 07 	lds	r24, 0x0705	; 0x800705 <uxTopReadyPriority>
 bc8:	90 e0       	ldi	r25, 0x00	; 0
 bca:	fc 01       	movw	r30, r24
 bcc:	ee 0f       	add	r30, r30
 bce:	ff 1f       	adc	r31, r31
 bd0:	ee 0f       	add	r30, r30
 bd2:	ff 1f       	adc	r31, r31
 bd4:	ee 0f       	add	r30, r30
 bd6:	ff 1f       	adc	r31, r31
 bd8:	8e 0f       	add	r24, r30
 bda:	9f 1f       	adc	r25, r31
 bdc:	fc 01       	movw	r30, r24
 bde:	ed 5c       	subi	r30, 0xCD	; 205
 be0:	f8 4f       	sbci	r31, 0xF8	; 248
 be2:	80 81       	ld	r24, Z
 be4:	88 23       	and	r24, r24
 be6:	29 f0       	breq	.+10     	; 0xbf2 <vTaskSwitchContext+0x36>
 be8:	1b c0       	rjmp	.+54     	; 0xc20 <vTaskSwitchContext+0x64>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
 bea:	81 e0       	ldi	r24, 0x01	; 1
 bec:	80 93 01 07 	sts	0x0701, r24	; 0x800701 <xMissedYield>
 bf0:	08 95       	ret
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
 bf2:	80 91 05 07 	lds	r24, 0x0705	; 0x800705 <uxTopReadyPriority>
 bf6:	81 50       	subi	r24, 0x01	; 1
 bf8:	80 93 05 07 	sts	0x0705, r24	; 0x800705 <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 bfc:	80 91 05 07 	lds	r24, 0x0705	; 0x800705 <uxTopReadyPriority>
 c00:	90 e0       	ldi	r25, 0x00	; 0
 c02:	fc 01       	movw	r30, r24
 c04:	ee 0f       	add	r30, r30
 c06:	ff 1f       	adc	r31, r31
 c08:	ee 0f       	add	r30, r30
 c0a:	ff 1f       	adc	r31, r31
 c0c:	ee 0f       	add	r30, r30
 c0e:	ff 1f       	adc	r31, r31
 c10:	8e 0f       	add	r24, r30
 c12:	9f 1f       	adc	r25, r31
 c14:	fc 01       	movw	r30, r24
 c16:	ed 5c       	subi	r30, 0xCD	; 205
 c18:	f8 4f       	sbci	r31, 0xF8	; 248
 c1a:	80 81       	ld	r24, Z
 c1c:	88 23       	and	r24, r24
 c1e:	49 f3       	breq	.-46     	; 0xbf2 <vTaskSwitchContext+0x36>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
 c20:	80 91 05 07 	lds	r24, 0x0705	; 0x800705 <uxTopReadyPriority>
 c24:	90 e0       	ldi	r25, 0x00	; 0
 c26:	9c 01       	movw	r18, r24
 c28:	22 0f       	add	r18, r18
 c2a:	33 1f       	adc	r19, r19
 c2c:	22 0f       	add	r18, r18
 c2e:	33 1f       	adc	r19, r19
 c30:	22 0f       	add	r18, r18
 c32:	33 1f       	adc	r19, r19
 c34:	28 0f       	add	r18, r24
 c36:	39 1f       	adc	r19, r25
 c38:	d9 01       	movw	r26, r18
 c3a:	ad 5c       	subi	r26, 0xCD	; 205
 c3c:	b8 4f       	sbci	r27, 0xF8	; 248
 c3e:	11 96       	adiw	r26, 0x01	; 1
 c40:	ed 91       	ld	r30, X+
 c42:	fc 91       	ld	r31, X
 c44:	12 97       	sbiw	r26, 0x02	; 2
 c46:	02 80       	ldd	r0, Z+2	; 0x02
 c48:	f3 81       	ldd	r31, Z+3	; 0x03
 c4a:	e0 2d       	mov	r30, r0
 c4c:	12 96       	adiw	r26, 0x02	; 2
 c4e:	fc 93       	st	X, r31
 c50:	ee 93       	st	-X, r30
 c52:	11 97       	sbiw	r26, 0x01	; 1
 c54:	2a 5c       	subi	r18, 0xCA	; 202
 c56:	38 4f       	sbci	r19, 0xF8	; 248
 c58:	e2 17       	cp	r30, r18
 c5a:	f3 07       	cpc	r31, r19
 c5c:	29 f4       	brne	.+10     	; 0xc68 <vTaskSwitchContext+0xac>
 c5e:	22 81       	ldd	r18, Z+2	; 0x02
 c60:	33 81       	ldd	r19, Z+3	; 0x03
 c62:	fd 01       	movw	r30, r26
 c64:	32 83       	std	Z+2, r19	; 0x02
 c66:	21 83       	std	Z+1, r18	; 0x01
 c68:	fc 01       	movw	r30, r24
 c6a:	ee 0f       	add	r30, r30
 c6c:	ff 1f       	adc	r31, r31
 c6e:	ee 0f       	add	r30, r30
 c70:	ff 1f       	adc	r31, r31
 c72:	ee 0f       	add	r30, r30
 c74:	ff 1f       	adc	r31, r31
 c76:	8e 0f       	add	r24, r30
 c78:	9f 1f       	adc	r25, r31
 c7a:	fc 01       	movw	r30, r24
 c7c:	ed 5c       	subi	r30, 0xCD	; 205
 c7e:	f8 4f       	sbci	r31, 0xF8	; 248
 c80:	01 80       	ldd	r0, Z+1	; 0x01
 c82:	f2 81       	ldd	r31, Z+2	; 0x02
 c84:	e0 2d       	mov	r30, r0
 c86:	86 81       	ldd	r24, Z+6	; 0x06
 c88:	97 81       	ldd	r25, Z+7	; 0x07
 c8a:	90 93 58 07 	sts	0x0758, r25	; 0x800758 <pxCurrentTCB+0x1>
 c8e:	80 93 57 07 	sts	0x0757, r24	; 0x800757 <pxCurrentTCB>
 c92:	08 95       	ret

00000c94 <memset>:
 c94:	dc 01       	movw	r26, r24
 c96:	01 c0       	rjmp	.+2      	; 0xc9a <memset+0x6>
 c98:	6d 93       	st	X+, r22
 c9a:	41 50       	subi	r20, 0x01	; 1
 c9c:	50 40       	sbci	r21, 0x00	; 0
 c9e:	e0 f7       	brcc	.-8      	; 0xc98 <memset+0x4>
 ca0:	08 95       	ret

00000ca2 <strncpy>:
 ca2:	fb 01       	movw	r30, r22
 ca4:	dc 01       	movw	r26, r24
 ca6:	41 50       	subi	r20, 0x01	; 1
 ca8:	50 40       	sbci	r21, 0x00	; 0
 caa:	48 f0       	brcs	.+18     	; 0xcbe <strncpy+0x1c>
 cac:	01 90       	ld	r0, Z+
 cae:	0d 92       	st	X+, r0
 cb0:	00 20       	and	r0, r0
 cb2:	c9 f7       	brne	.-14     	; 0xca6 <strncpy+0x4>
 cb4:	01 c0       	rjmp	.+2      	; 0xcb8 <strncpy+0x16>
 cb6:	1d 92       	st	X+, r1
 cb8:	41 50       	subi	r20, 0x01	; 1
 cba:	50 40       	sbci	r21, 0x00	; 0
 cbc:	e0 f7       	brcc	.-8      	; 0xcb6 <strncpy+0x14>
 cbe:	08 95       	ret

00000cc0 <_exit>:
 cc0:	f8 94       	cli

00000cc2 <__stop_program>:
 cc2:	ff cf       	rjmp	.-2      	; 0xcc2 <__stop_program>
